import streamlit as st
import pandas as pd
import pickle
import os

# --- PAGE CONFIG ---
st.set_page_config(page_title="Course Recommender", layout="wide")

@st.cache_resource
def load_assets():
    try:
        # Load the files generated by your notebook
        full_df = pd.read_pickle('full_data.pkl')
        train_df = pd.read_pickle('train_data.pkl')
        with open('biases.pkl', 'rb') as f:
            biases = pickle.load(f)
        
        # We need the full dataframe to find other versions of the same course
        return full_df, train_df, biases
    except Exception as e:
        st.error(f"Error loading assets: {e}")
        return None, None, None

full_df, train_df, biases = load_assets()

# --- UI ---
st.title("ðŸŽ“ Online Course Recommendation System")

if full_df is not None:
    user_input = st.number_input("Enter User ID:", value=15796, step=1)

    if st.button("Generate Recommendations"):
        # 1. Recommendation Logic
        g_mean = biases['global_mean']
        u_b = biases['user_bias']
        i_b = biases['item_bias']
        
        # Get courses not yet taken
        seen = train_df[train_df['userid'] == user_input]['courseid'].unique()
        all_c = train_df['courseid'].unique()
        candidates = [c for c in all_c if c not in seen]
        
        results = []
        for cid in candidates:
            # Hybrid Score Calculation
            cf_score = g_mean + u_b.get(user_input, 0) + i_b.get(cid, 0)
            item_mean = train_df[train_df['courseid'] == cid]['rating'].mean()
            score = 0.5 * cf_score + 0.5 * item_mean
            results.append((cid, score))
        
        # Sort and take top 5
        results.sort(key=lambda x: x[1], reverse=True)
        top_5 = pd.DataFrame(results[:5], columns=['course_id', 'recommendation_score'])
        
        # Merge with metadata (using full_df to get names and instructors)
        # We drop duplicates on course_id to ensure a 1:1 merge
        lookup = full_df[['course_id', 'course_name', 'instructor', 'rating']].drop_duplicates('course_id')
        final_recs = top_5.merge(lookup, on='course_id', how='left')
        
        # Format the score to 6 decimal places as requested
        final_recs['recommendation_score'] = final_recs['recommendation_score'].map('{:.6f}'.format)
        
        # Display the Exact Table Format
        st.subheader(f"Top Recommendations for User {user_input}")
        st.table(final_recs[['course_id', 'recommendation_score', 'course_name', 'instructor', 'rating']])
        
        # Store in session state for the next feature
        st.session_state['recs_table'] = final_recs

    # --- NEW: SEARCH FOR HIGHER RATED VERSIONS OF THE SAME COURSE ---
    if 'recs_table' in st.session_state:
        st.divider()
        st.subheader("ðŸŽ¯ Find Better Versions of These Courses")
        
        selected_name = st.selectbox(
            "Select a course to see other instructors with higher ratings:",
            ["Select..."] + st.session_state['recs_table']['course_name'].tolist()
        )
        
        if selected_name != "Select...":
            # Find the rating of the course currently in the recommendation list
            current_rating = st.session_state['recs_table'][
                st.session_state['recs_table']['course_name'] == selected_name
            ]['rating'].iloc[0]
            
            # Search the entire dataset for the SAME course name but HIGHER rating
            better_versions = full_df[
                (full_df['course_name'] == selected_name) & 
                (full_df['rating'] > current_rating)
            ].sort_values(by='rating', ascending=False).drop_duplicates('instructor')
            
            if not better_versions.empty:
                st.success(f"Found {len(better_versions)} versions of **{selected_name}** with higher ratings!")
                st.table(better_versions[['course_id', 'course_name', 'instructor', 'rating', 'course_price']])
            else:
                st.info(f"The recommended version of **{selected_name}** is already among the highest rated available.")

else:
    st.error("Please ensure your .pkl files are in the directory.")
