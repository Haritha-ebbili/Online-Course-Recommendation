import streamlit as st
import pandas as pd
import pickle
import os

# --- PAGE CONFIG ---
st.set_page_config(page_title="Dynamic Course Recommender", layout="wide")

@st.cache_resource
def load_assets():
    try:
        # Load the files generated by your notebook
        full_df = pd.read_pickle('full_data.pkl')
        train_df = pd.read_pickle('train_data.pkl')
        with open('biases.pkl', 'rb') as f:
            biases = pickle.load(f)
        return full_df, train_df, biases
    except Exception as e:
        st.error(f"Error loading assets: {e}")
        return None, None, None

full_df, train_df, biases = load_assets()

# --- UI ---
st.title("ðŸŽ“ Online Course Recommendation System")

if full_df is not None:
    # 1. User ID Input with Dynamic Reset
    # The 'key' helps Streamlit track this specific input
    user_id = st.number_input("Enter User ID:", value=15796, step=1, key="main_user_input")

    # If the user ID changes, we clear the session state to force new calculations
    if "current_user" not in st.session_state:
        st.session_state.current_user = user_id

    if st.session_state.current_user != user_id:
        st.session_state.current_user = user_id
        if 'recommendations' in st.session_state:
            del st.session_state['recommendations']

    # 2. Generate Button
    if st.button("Generate Recommendations"):
        # Prediction Logic
        g_mean = biases['global_mean']
        u_b = biases['user_bias']
        i_b = biases['item_bias']
        
        # Identify courses already taken by this specific user
        seen_ids = train_df[train_df['userid'] == user_id]['courseid'].unique()
        all_unique_ids = train_df['courseid'].unique()
        candidate_ids = [c for c in all_unique_ids if c not in seen_ids]
        
        scores = []
        for cid in candidate_ids:
            # Hybrid Calculation
            cf_part = g_mean + u_b.get(user_id, 0) + i_b.get(cid, 0)
            item_mean = train_df[train_df['courseid'] == cid]['rating'].mean()
            final_score = 0.5 * cf_part + 0.5 * item_mean
            scores.append((cid, final_score))
        
        # Sort and pick top 5
        scores.sort(key=lambda x: x[1], reverse=True)
        top_5_df = pd.DataFrame(scores[:5], columns=['course_id', 'recommendation_score'])
        
        # Merge with metadata (deduplicated by ID)
        lookup = full_df[['course_id', 'course_name', 'instructor', 'rating']].drop_duplicates('course_id')
        final_table = top_5_df.merge(lookup, on='course_id', how='left')
        
        # Format score to 6 decimal places
        final_table['recommendation_score'] = final_table['recommendation_score'].map('{:.6f}'.format)
        
        # Store in session state
        st.session_state['recommendations'] = final_table

    # --- DISPLAY TABLE ---
    if 'recommendations' in st.session_state:
        recs = st.session_state['recommendations']
        st.subheader(f"Top Recommendations for User {user_id}")
        st.table(recs[['course_id', 'recommendation_score', 'course_name', 'instructor', 'rating']])

        # --- REFINEMENT: SAME COURSE, DIFFERENT INSTRUCTORS ---
        st.divider()
        st.subheader("ðŸŽ¯ Refine: Same Course, Different Instructor")
        
        # Dropdown for the courses listed above
        selected_name = st.selectbox(
            "Select a course to see other available instructors and ratings:",
            ["Select..."] + recs['course_name'].tolist(),
            key=f"dropdown_{user_id}" # Reset dropdown when User ID changes
        )
        
        if selected_name != "Select...":
            # Get the ID of the version currently in the recommendation table
            current_id = recs[recs['course_name'] == selected_name]['course_id'].iloc[0]
            
            # Search the whole dataset for the same name but different ID/Instructor
            alternatives = full_df[
                (full_df['course_name'] == selected_name) & 
                (full_df['course_id'] != current_id)
            ].sort_values(by='rating', ascending=False)
            
            if not alternatives.empty:
                st.write(f"Other versions of **{selected_name}** found in the dataset:")
                st.table(alternatives[['course_id', 'course_name', 'instructor', 'rating', 'course_price']].reset_index(drop=True))
            else:
                st.info("No other instructors found for this specific course name.")

else:
    st.error("Assets not found. Please verify full_data.pkl, train_data.pkl, and biases.pkl exist.")
